<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最大子数组和</title>
      <link href="/2023/10/04/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2023/10/04/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。 </p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Status</span>&#123;</span><br><span class="line">        <span class="type">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">        <span class="type">int</span> lSum = <span class="built_in">max</span>(l.lSum, l.iSum + r.lSum);</span><br><span class="line">        <span class="type">int</span> rSum = <span class="built_in">max</span>(r.rSum, r.iSum + l.rSum);</span><br><span class="line">        <span class="type">int</span> mSum = <span class="built_in">max</span>(<span class="built_in">max</span>(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">        <span class="keyword">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Status <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (r+l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">             <span class="keyword">return</span> (Status) &#123;nums[l],nums[l],nums[l],nums[l]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Status lSub = <span class="built_in">get</span>(nums, l, mid);</span><br><span class="line">        Status rSub = <span class="built_in">get</span>(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pushUp</span>(lSub, rSub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><h5 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h5><p>将数组不断拆分，计算左右两部分的最大子数组和横跨$mid$的最大子数组，从而计算出该数组的最大子数组。</p><p>假设序列 $a$ 的长度为 $n$。</p><p>时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 O($\log⁡{n}$)，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum\limits_{i=1}^{\log{n}}2^{i-1})=O(n)$，故渐进时间复杂度为 $O(n)$。<br>空间复杂度：递归会使用 $O(\log⁡n)$ 的栈空间，故渐进空间复杂度为 $O(\log⁡n)$。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并K个升序列表</title>
      <link href="/2023/10/03/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
      <url>/2023/10/03/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((!a)||(!b))  <span class="keyword">return</span> a?a:b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span>(aPtr&amp;&amp;bPtr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(aPtr-&gt;val &lt; bPtr-&gt;val)&#123;</span><br><span class="line">                tail-&gt;next = aPtr;</span><br><span class="line">                aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = bPtr;</span><br><span class="line">                bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = aPtr?aPtr:bPtr;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)  <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>​使用分治将问题分解为两个链表的合并。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找两个正整数的中位数</title>
      <link href="/2023/10/03/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2023/10/03/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><hr><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><h4 id="c语言："><a href="#c语言：" class="headerlink" title="c语言："></a>c语言：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(index1==nums1Size)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums2[k+index2<span class="number">-1</span>];</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span>(index2==nums2Size)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[k+index1<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[index1]&lt;nums2[index2]?nums1[index1]:nums2[index2];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> newindex1 = (index1+k/<span class="number">2</span><span class="number">-1</span>)&lt;(nums1Size<span class="number">-1</span>)?(index1+k/<span class="number">2</span><span class="number">-1</span>):(nums1Size<span class="number">-1</span>);</span><br><span class="line">      <span class="type">int</span> newindex2 = (index2+k/<span class="number">2</span><span class="number">-1</span>)&lt;(nums2Size<span class="number">-1</span>)?(index2+k/<span class="number">2</span><span class="number">-1</span>):(nums2Size<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span>(nums1[newindex1]&lt;=nums2[newindex2])&#123;</span><br><span class="line">        k -= newindex1 - index1 +<span class="number">1</span>;</span><br><span class="line">        index1 = newindex1+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        k -= newindex2 - index2 +<span class="number">1</span>;</span><br><span class="line">        index2 = newindex2+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size)</span>&#123;</span><br><span class="line">  <span class="type">int</span> l = nums1Size + nums2Size;</span><br><span class="line">  <span class="keyword">if</span>(l%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> getKth(nums1,nums1Size,nums2,nums2Size,(l+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((getKth(nums1,nums1Size,nums2,nums2Size,(l/<span class="number">2</span>))+getKth(nums1,nums1Size,nums2,nums2Size,(l/<span class="number">2</span>+<span class="number">1</span>)))/<span class="number">2.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nums1[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> nums2[<span class="number">2</span>]=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,findMedianSortedArrays(nums1,<span class="number">2</span>,nums2,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>​使用getKth函数找到第k个元素（通过这个查找中位数），算法复杂度 $ \log(m+n) $ ，其中m、n为数组 $nums1$和$nums2$ 长度。</p><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>​最后当$k%2&#x3D;&#x3D;0$时的返回值除以二之前的括号漏加，巧合通过case1，未通过case2，后断点调试、打印相关之找出错误。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex入门</title>
      <link href="/2023/09/25/LaTex%E5%85%A5%E9%97%A8/"/>
      <url>/2023/09/25/LaTex%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Letex入门-刘海洋"><a href="#Letex入门-刘海洋" class="headerlink" title="Letex入门[刘海洋]"></a>Letex入门[刘海洋]</h1><p>​对于LaTex学习的一些相关笔记，基于《LaTex入门（刘海洋）》。</p><h2 id="第一章-熟悉LaTex"><a href="#第一章-熟悉LaTex" class="headerlink" title="第一章 熟悉LaTex"></a>第一章 熟悉LaTex</h2><h3 id="1-2-2-提纲"><a href="#1-2-2-提纲" class="headerlink" title="1.2.2 提纲"></a>1.2.2 提纲</h3><p>一个例子：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%-*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="comment">% gougu</span></span><br><span class="line"><span class="comment">% 勾股定理</span></span><br><span class="line"><span class="keyword">\documentclass</span>[UTF-8]&#123;ctexdart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;杂谈勾股定理&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;张三&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;plain&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\section</span>&#123;勾股定理在古代&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;勾股定理的近代形式&#125;</span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;math&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>框架说明：</p><p>​%开头为注释；document{ctexart} 括号中为文档类，其中ctexart表示中文类短文，UTF-8为编码；后三行申明文章标题、作者、写作日期，通过\maketitle对文章星系进行排版后才显示；\bibliographystyle声明参考文献格式（详见第三章）</p><p>​以上在\begin{document}之前的称为导言区，对文档性质进行一些设置，自定义命令等。</p><p>​\begin{document}和\end{document}声明一个document环境，中间为正文部分。其中maketitle输出论文标题，titleofcontents输出目录，section为开始的新一节，文末的bibliographystyle{math}提示从文献数据库math当中获取文献信息，打印参考文献列表。</p><h3 id="1-2-3-正文"><a href="#1-2-3-正文" class="headerlink" title="1.2.3 正文"></a>1.2.3 正文</h3><ul><li><p>使用空行分段，空行使文字另起一段。</p></li><li><p>段前自动缩进，不需要打空格。</p></li><li><p>汉字后的空格会被忽略，其他符号会保留；单个换行相当于空格。</p><p>  使用xelatex时，ctexaart文档会调用xeCJK宏包，自动处理汉字与其他符号之间的距离。</p></li></ul><h3 id="1-2-4-命令与环境"><a href="#1-2-4-命令与环境" class="headerlink" title="1.2.4 命令与环境"></a>1.2.4 命令与环境</h3><p>脚注命令：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">这里是一段文字<span class="keyword">\footnote</span>&#123;这里是一段脚注&#125;这里又是一段接着的文字</span><br></pre></td></tr></table></figure><p>强调(emphasis)：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">这里是一段普通的文字<span class="keyword">\emph</span>&#123;这里是强调的文字&#125;。</span><br></pre></td></tr></table></figure><p>命令（宏）的格式：</p><p>无参数\command</p><p>有n个参数\command<arg1><arg2>……<argn></p><p>有可选参数\command[<argopt>]<arg1>……<argn></p><p>​命令名是一串字母或者单个符号，可以带参数。命令参数不只一个字符，则用花括号{}括起来，可选参数用[]括起来</p><p>引用的内容：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;quote&#125;</span><br><span class="line">这里是引用的内容</span><br><span class="line"><span class="keyword">\zihao</span>&#123;-5&#125;<span class="keyword">\kaishu</span> 引用的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;quote&#125;</span><br></pre></td></tr></table></figure><p>​quote以begin和end为起始位置，其中内容单独分行，增加缩进和上下间距排版，以突出引用。</p><p>​quote不改变字体，可以用命令改变。其中\zihao是改变字号命令，-5为小字号。</p><p>​类似地，文章摘要是在\maketitle之后使用abstract环境生成。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;abstract&#125;</span><br><span class="line">这里是文章摘要。</span><br><span class="line"><span class="keyword">\end</span>&#123;abstract&#125;</span><br></pre></td></tr></table></figure><p>​选择字号和字体的命令和脚注不同，会对后面所有文字产生影响，直到分组结束。</p><p>​一个latex环境就是一个分组，也可以用成对的花括号产生一个分组。</p><p>定理环境：</p><p>​文章第二节的定理是用第一类环境输出的。</p><p><img src="https://raw.githubusercontent.com/remeinma/picture/main/Img/202309251549168.png" alt="image-20230925154833590"></p><p>​定理环境是一类环境，使用之前需要在导言区先做定义。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;</span><br></pre></td></tr></table></figure><p>​定义一个thm环境，定理环境可以有一个名字。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thm&#125;[勾股定理]</span><br><span class="line">这里是定理的具体内容。</span><br><span class="line"><span class="keyword">\end</span>&#123;thm&#125;</span><br></pre></td></tr></table></figure><p>​在表示起止年份时使用了–，在latex当中会输出一个en dash，即宽度与”n”相当的短线，通常用来表示数字的范围。</p><h3 id="1-2-5-数学公式"><a href="#1-2-5-数学公式" class="headerlink" title="1.2.5 数学公式"></a>1.2.5 数学公式</h3><p>​简单方式：将数学公式使用$ $括起来，得到花体数学公式；这种数学公式夹在行内，称为正文公式或者行内公式。</p><p>​较长公式单独一行或者一段显示，称为显示公式或者列表公式，使用eqtation环境可以方便输入这种公式。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">a(b+c) = ab * ac</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><p>一些特殊数学符号：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \angle 表示∠; \pi 表示Π</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\angle</span> ACB = <span class="keyword">\pi</span> /2<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ^引入上标，而_引入下标</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">AB<span class="built_in">^</span>2 = BC<span class="built_in">^</span>2 + AC<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% latex中没有表示°的符号，通过上标实现。</span></span><br><span class="line"><span class="comment">% 这里的\circ是一个通常用来表示函数复合的二元运算符。</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">^</span><span class="keyword">\circ</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><h3 id="1-2-6-使用图表"><a href="#1-2-6-使用图表" class="headerlink" title="1.2.6 使用图表"></a>1.2.6 使用图表</h3><h4 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h4><p>​两种途径：插入事先准备好的图片、直接在文档中画图。</p><p>​插入图片由\usepackage命令引入宏包。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\document</span>&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>(graphicx)</span><br><span class="line"><span class="comment">% ……导言区其他内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 引入后可以插入图片</span></span><br><span class="line"><span class="comment">% []内为图片宽度，&#123;&#125;内为图片名称</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=3cm]&#123;图片名称.pdf&#125;</span><br></pre></td></tr></table></figure><p>​[]内为图片宽度，{}内为图片名称；其他参数：scale&#x3D;{放缩因子}、height&#x3D;{高度}等。很少将图片夹在文字当中，通常将图片放在可以变动的相对位置当中，为浮动体。可以为浮动体加上说明性的标题。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[ht]</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[scale = 0.6]&#123;图片名称.pdf&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;图片说明性标题&#125;</span><br><span class="line"><span class="keyword">\label</span>&#123;fig:图片名称&#125;<span class="comment">%给图片定义一个标签</span></span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><p>​figure为浮动体环境，可选参数[ht]为here和top，浮动体可以出现在环境周围文本所在处和一页的顶部；环境内相当于普通段落，没有缩进；centering表示居中，capture自动加上编号和标题，label定义一个标签，在后文可以引用capture产生的图片编号。</p><h4 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h4><p>​表格一般在latex中直接制作，由tabular环境完成。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|rrr|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">直角边 <span class="built_in">$</span>a<span class="built_in">$</span> <span class="built_in">&amp;</span> 直角边 <span class="built_in">$</span>b<span class="built_in">$</span> <span class="built_in">&amp;</span> 斜边 <span class="built_in">$</span>c<span class="built_in">$</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">3 <span class="built_in">&amp;</span>4 <span class="built_in">&amp;</span> 5 <span class="keyword">\\</span></span><br><span class="line">5 <span class="built_in">&amp;</span>12 <span class="built_in">&amp;</span> 13 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure><p>​tabular环境当中有三个参数，声明了列的模式。|rrr|表示有三列，右对齐，在第一列和第三列当中各有一条垂直的表格线；在环境内部行与行之间用\\分隔，每行内部由&amp;分隔，表格中的横线由\hline生成。</p><p>​产生的表格和插图一样，是一个大盒子，一般放在浮动环境中，即table当中，capture得到的标题是表不是图。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[H]</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|rrr|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">直角边 <span class="built_in">$</span>a<span class="built_in">$</span> <span class="built_in">&amp;</span> 直角边 <span class="built_in">$</span>b<span class="built_in">$</span> <span class="built_in">&amp;</span> 斜边 <span class="built_in">$</span>c<span class="built_in">$</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">3 <span class="built_in">&amp;</span>4 <span class="built_in">&amp;</span> 5 <span class="keyword">\\</span></span><br><span class="line">5 <span class="built_in">&amp;</span>12 <span class="built_in">&amp;</span> 13 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;<span class="comment">%</span></span><br><span class="line"><span class="keyword">\qquad</span></span><br><span class="line">(<span class="built_in">$</span>a<span class="built_in">^</span>2 + b<span class="built_in">^</span>2 = c<span class="built_in">^</span>2<span class="built_in">$</span>)</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure><p>​这里将表格和一个公式并排，中间用\qquad分隔，产生长为2em的空白。在\end{tabular}后加一个注释符取消换行产生的一个多余空格，达到预想结果。</p><p>​这种方式放置表格和正文是连接在一起的，不允许浮动，但是我们仍然使用了浮动table，但是[H]使其固定，由于是float宏包提供的环境，还需要引入\usepackage{float}.</p><h3 id="1-2-7-自动化工具"><a href="#1-2-7-自动化工具" class="headerlink" title="1.2.7 自动化工具"></a>1.2.7 自动化工具</h3><p>​bibtex使用的参考文献库是一个后缀为.bib的文件。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% this file was created with JabRef 2.6</span></span><br><span class="line"><span class="comment">% Encoding:UTF-8</span></span><br><span class="line">@BOOK&#123;引用标签,</span><br><span class="line">title = &#123;参考文献标题&#125;,</span><br><span class="line">publisher = &#123;出版社&#125;,</span><br><span class="line">year = &#123;出版年份&#125;,</span><br><span class="line">author = &#123;作者&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ARTICLE&#123;引用标签,</span><br><span class="line">title = &#123;参考文献标题&#125;,</span><br><span class="line">publisher = &#123;出版社&#125;,</span><br><span class="line">year = &#123;出版年份&#125;,</span><br><span class="line">author = &#123;作者&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​代码开头数据库文件的两行注释是由文献管理工具JabRef制作的（详见3.3.2），现实中bibtex数据库不需要自己手动录入，相关学科网站可以直接下载。</p><p>​使用bibtex处理文献时，编译.tex文件时就增加为四次编译。</p><p>​xelatexxxx.tex</p><p>​biblatexxxx.aux</p><p>​xelatexxxx.tex</p><p>​xelatexxxx.tex</p><p>​latex只选择被引用的文献，引用即\cite命令引用引用标签；如果要显示未被引用的标签，可以使用\notice命令。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\notice</span>&#123;引用标签&#125;</span><br><span class="line"><span class="keyword">\bibliography</span>&#123;math&#125;</span><br></pre></td></tr></table></figure><p>​引用不限制于参考文献。基本交叉引用命令为\ref，以标签为参数，得到被引用的编号。例如：在插图时已经用\label为插图定义了标签fig:xiantu，于是，在正文当中可以使用</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">图 <span class="keyword">\ref</span>&#123;fig:xiantu&#125; 是我国古代对勾股定理的一种证明 <span class="keyword">\cite</span>&#123;quanjing&#125;</span><br></pre></td></tr></table></figure><p>​公式编号也可以这样引用，但是需要在公式中先定义标签：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;<span class="keyword">\label</span>&#123;eq:gougu&#125;</span><br><span class="line">AB<span class="built_in">^</span>2 = BC<span class="built_in">^</span>2 + AC<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><p>​然后在正文当中以(\ref{eq:gougu})引用。</p><p>​数学宏包amsmath定义了\eqref命令，专门用于公式的引用，并产生括号：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区使用 \usepackage&#123;amsmath&#125;</span></span><br><span class="line">满足式 <span class="keyword">\eqref</span>&#123;eq:gougu&#125; 的整数称为 <span class="keyword">\emph</span>&#123;勾股数&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-8-设计文章的格式"><a href="#1-2-8-设计文章的格式" class="headerlink" title="1.2.8 设计文章的格式"></a>1.2.8 设计文章的格式</h3><p>​设计页面尺寸可以使用gometry宏包（详见2.4.2）</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usapackage</span>&#123;geometry&#125;</span><br><span class="line">geometry&#123;a6paper,centering,scale = 0.8&#125;</span><br></pre></td></tr></table></figure><p>​改变图标标题格式可以使用caption宏包（详见5.3.2）</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[format = hang,font = small,textfont = it]&#123;caption&#125;</span><br></pre></td></tr></table></figure><p>​设定图表所有标题为悬挂对其方式（即编号向左突出），整体用小字号，标题文本用斜体。</p><p>​增加目录的项目可以使用tocaibind宏包</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[nottoc]&#123;tocbibind&#125;</span><br></pre></td></tr></table></figure><p>​默认在目录当中加入目录项本身、参考文献、索引等项目；这里的nottoc取消了在目录中显示目录本身。</p><p>​标题、作者的字体可以直接在\title、\author中设定。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\heiti</span> 标题&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\kaishu</span> 作者&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br></pre></td></tr></table></figure><p>​正文当中的引用quote环境中夹杂着字体命令，不方便修改，可以利用\newenvironment命令定义一个新环境，在原来quote的基础上增加格式控制。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newenvironment</span>&#123;myquote&#125;</span><br><span class="line">&#123;<span class="keyword">\begin</span>&#123;quote&#125;<span class="keyword">\kaishu</span><span class="keyword">\zihao</span>&#123;-5&#125;&#125;</span><br><span class="line">&#123;<span class="keyword">\end</span>&#123;quote&#125;&#125;</span><br></pre></td></tr></table></figure><p>​这里有三个参数，分别是环境的名字、环境开始和末尾处的代码，因此可以使用新环境：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;myquote&#125;</span><br><span class="line">引用内容</span><br><span class="line"><span class="keyword">\end</span>&#123;myquote&#125;</span><br></pre></td></tr></table></figure><p>​类似地，原来数学公式当中的^\circ也可以定义一个新的命令\degree</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\degree</span>&#123;<span class="built_in">^</span><span class="keyword">\circ</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 一些个其他学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/2023/09/04/My-first-blog/"/>
      <url>/2023/09/04/My-first-blog/</url>
      
        <content type="html"><![CDATA[<p>使用github + hexo搭建的个人blog平台。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/04/hello-world/"/>
      <url>/2023/09/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
